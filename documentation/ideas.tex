\documentclass[12pt, a4paper]{report}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{ragged2e}
\usepackage{xurl}

\usepackage[a4paper, top=2cm, bottom=2cm, left=3cm, right=3cm]{geometry}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{cleveref}
\usepackage{csquotes}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}

\usepackage[nonumberlist, acronym]{glossaries}

\usepackage{tcolorbox}
\tcbuselibrary{listings, breakable}

\newtcblisting{mytcblisting}[2][]{%
  listing only,
  breakable,
  colframe=black,
  colback=white,
  boxsep=5pt,
  title={#2},
  listing options={
    basicstyle=\ttfamily\small,
    breaklines=true,
    breakatwhitespace=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    columns=fullflexible,
    keepspaces=true,
    language=C,
    numbers=left,
    numbersep=10pt,
    stepnumber=1,
    firstnumber=1,
    numberstyle=\tiny\color{gray}
  },
  #1
}

\bibliographystyle{plain}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    filecolor=black,
    urlcolor=black
}

\newtheoremstyle{note}
    {3pt}
    {3pt}
    {}
    {1.25cm}
    {\bfseries}
    {.}
    { }
    {}

% Несколько полезных блоков для выделения важных частей текста. Пример:
% \begin{theorem}
%   Если $a$ и $b$ — положительные числа, то $a + b \geq 2\sqrt{ab}$.
% \end{theorem}
\theoremstyle{note}
\newtheorem*{note}{Замечание}
\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{corollary}{Следствие}
\newcommand{\R}[2]{\mathbb{R}^{#1 \times #2}}
\newcommand{\Rn}{\mathbb{R}^n}

\begin{document}

\tableofcontents

\chapter{Уточнение поворотов Гивенса в implicit zero-shift QR}

\section{Схождение алгоритма}
В данном разделе рассмотрим критерии сходимости для нашего алгоритма, который является совмещением обычного shifted QR и implicit zero-shift QR, приведения бидиагольной матрицы $B$ к диагональной $\Sigma$. Пусть $s_1, s_2,...,s_n$ \--- диагональные элементы, а $e_1, e_2, ..., e_{n-1}$ \--- элементы на побочной диагонали нашей матрицы $B$. Также есть некоторый критерий допуска $tol$, который зависит от желаемой относительной точности сингулярных значений. Он должен быть меньше 1, но больше машинной точности \epsilon.

Наш критерий сходимости должен гарантировать, что обнуление $e_i$ сильно не повлияет на сингулярные значения. К примеру, код в LINPACK имеет два разных порога для обнуления элемента:
\begin{align}
\text{Если } (|e_i| + |e_{i-1}| + |s_i| = |e_i| + |e_{i-1}|), \text{ то обнуляем }s_i
\\\text{Если } (|s_i| + |s_{i-1}| + |e_{i-1}| = |s_i| + |s_{i-1}|), \text{ то обнуляем }e_{i-1}
\end{align}

Оба случая не подходят для нашего алгоритма. При случае $(1.1)$ нулевые сингулярные значения будут получаться там, где их не было до этого. Второй вариант $(1.2)$ также является неудовлетворительным. Покажем это на примере: возьмем $\eta$ настолько маленького значения, что в арифметике с плавающей точкой $1+\eta=1$. Тогда рассмотрим матрицу
\begin{center}
$B(x)=\begin{pmatrix}
    \eta^2&1&&\\
    &1&x\\
    &&1&1\\
    &&&\eta^2
\end{pmatrix}$
\end{center}

\noindentПри $x=\eta$ самое минимальное сингулярное значение $B(\eta)$ будет примерно равно $\eta^3$. Рассматриваемый критерий обнулит $\eta$, но $B(0)$ имеет минимальное сингулярное значение возле $\frac{\eta^2}{\sqrt{2}}$, что недопустимо отличается.

Пусть $\sigma$ обозначет нижнюю границу для наименьшего сингулярного значения, тогда самый простой допустимый вариант будет установка $e_i$ равными 0, если значение меньше, чем $tol\cdot\sigma$. Однако, при таком методе, наши числа на побочной диагонали будут зануляться очень долго. Гораздо лучшие критерии можно получить такими способами:
\newpageПусть $\lambda_j$ и $\mu_j$ вычисляются с помощью данных реккурентных соотношений:

\begin{minipage}{0.48\textwidth}
\begin{align*}
\mu_1& = |s_1| \\
\text{for }& j = 1 \text{ to } n-1 \text{ do} \\
&\mu_{j+1} = |s_{j+1}| \cdot \left( \frac{\mu_j}{\mu_j + |e_j|} \right)
\end{align*}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
\begin{align*}
\lambda_n& = |s_n| \\
\text{for }& j = n-1 \text{ to } 1 \text{ step } -1 \text{ do} \\
&\lambda_j = |s_j| \cdot \left( \frac{\lambda_{j+1}}{\lambda_{j+1} + |e_j|} \right)
\end{align*}
\end{minipage}
\vspace{1em}

\noindent\textit{Критерий сходимости 1a}. Если $|\frac{e_j}{\mu_j}|\leq tol$, то обнуляем $e_j$.\vspace{1em}
\\\textit{Критерий сходимости 1b}. Если $|\frac{e_j}{\lambda_{j+1}}|\leq tol$, то обнуляем $e_j$.\vspace{1em}
\\\textit{Критерий сходимости 2a}. Если сингулярные вектора не требуеются и\linebreak $e^2_{n-1}\leq0.5\cdot tol\cdot [(\frac{\min\limits_{j<n}\mu_j}{\sqrt{n-1}})^2-|s_n|^2]$, то обнуляем $e_{n-1}$.\vspace{1em}
\\\textit{Критерий сходимости 2b}. Если сингулярные вектора не требуеются и\linebreak $e^2_1\leq0.5\cdot tol\cdot [(\frac{\min\limits_{j>1}\lambda_j}{\sqrt{n-1}})^2-|s_1|^2]$, то обнуляем $e_1$.\vspace{1em}

Эти критерии требуют больше вычислительных затрат, чем критерии, реализованные в библиотеке LINPACK, зато помогают избежать ситуаций, когда обнуление значения приводит к недопустимой относительной ошибке.


% Способы определения схождения алгоритма на этапе "подкрутки алгоритмов". lawn03, страница 17
\chapter{"Обратный" поворот Якоби}

\section{Принцип сведения $A$ к \Sigma}
В отличие от первой идеи, метод Якоби предполагает работу с изначальной матрицей $A$ при помощи поворотов Якоби (\ref{eq:2:1}), однако это то же самое, что повороты Гивенса. Есть два варианта работы алгоритма:\textit{ двусторонний метод Якоби, односторонний метод Якоби}.
\begin{equation} \label{eq:2:1}
    J(i,j,\theta) = 
    \begin{pmatrix}E&&&&\\
        &c&&s\\
        &&E&&\\
        &-s&&c\\
        &&&&E
    \end{pmatrix},\
    c = \cos(\theta), s =\sin(\theta) 
\end{equation}
\paragraph{Двусторонний метод Якоби}
Этот метод предполагает домножение изначальной матрицы $A$ слева на $J(i,j,\theta)$, справа на $K(i,j,\phi)$ таким образом, чтобы занулить недиагональные элементы, пока $\left\| A - diag(A) \right\|_F > tol$, $tol$ - заданный допуск. 
Отсюда следует рекуррентная последовательность, позволяющая получить сингулярные значения $\Sigma$
\begin{center}
    $A_{(k+1)} = J^T_{(k)}A_{(k)}K_{(k)}, \ A_{(0)}= A, \ A_{(k)}\longrightarrow\Sigma \text{ при } k\to\infty$
\end{center}

Левые повороты при перемножении дают левый сингулярный вектор, $U=J_{(0)}J_{(1)}...$, аналогично, правые повороты - правый сингулярный вектор $V=K_{(0)}K_{(1)}...$

Чтобы определить матрицы $J(i,j,\theta), K(i,j,\phi)$ требуется рассмотреть уравнение
\begin{equation}
    \hat{J}_{(k)}^T\hat{A}_{(k)}\hat{K}_{(k)} = \begin{pmatrix}
        c_J&s_J\\
        -s_J&c_J
    \end{pmatrix}^T
    \begin{pmatrix}
        a_{ii}&a_{ij}\\
        a_{ji}&a_{jj}
    \end{pmatrix}
    \begin{pmatrix}
        c_K&s_K\\
        -s_K&c_K
    \end{pmatrix} = \begin{pmatrix}
        d_{ii} &\\
        &d_{jj}
    \end{pmatrix} = A_{(k+1)},
\end{equation}
где $d_{ii}, d_{jj} -\text{сингулярные числа } \hat{A}_{(k)}$

Однако углы для $J, K$ находятся неоднозначно.
\paragraph{Односторонний метод Якоби}

Идея метода заключается в том, чтобы использовать матрицу поворота Якоби к изначальной матрице $A$ только с правой стороны - $AJ$ для ортогонализации столбцов $A$, что неявно является двусторонним методом Якоби для матрицы $A^TA$.
Столбцы матрицы сходятся к $U\Sigma$, где левые сингулярные вектора перемножаются с сингулярными значениями.
\begin{center}
    $A_{(0)}=A,\ A_{(k+1)} = A_{(k)}J_{(k)},\ A_{(k)} \longrightarrow U\Sigma, \text{ при } k\to\infty$
\end{center}
Отсюда неявно следует, что $A^T_{(k)}A_{(k)} \to \Sigma^2$. Аналогично двустороннему методу Якоби $V = J_{(0)}J_{(1)}...$, получаем правый сингулярный вектор.
Для определения матрицы поворота требуется рассмотреть уравнение.
\begin{equation}
    \hat{J}^T_{(k)}\begin{pmatrix}
        b_{ii}&b_{ij}\\
        b_{ji}&b_{jj}
    \end{pmatrix}\hat{J}_{(k)} = \begin{pmatrix}
        d_{ii} &\\
        & d_{jj}
    \end{pmatrix},
\end{equation}
где $b_{ij} = a_i^Ta_j, a_i-\text{i-ый столбец }A_{(k)},\ d_{ii}, d_{jj} -\text{собственные числа } A^TA$.
% Описать работу первого шага алгоритма
% раздел 12 https://pure.manchester.ac.uk/ws/files/82231456/17m1117732.pdf 
% golub van loan 8.6

\chapter{"Наивный" метод}

\chapter{Скрученные преобразования}

\end{document}